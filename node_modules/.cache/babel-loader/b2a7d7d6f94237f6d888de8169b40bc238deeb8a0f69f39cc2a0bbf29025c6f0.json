{"ast":null,"code":"export function breadthFirstSearch(grid, startNode, finishNode, getNeighbourNodes) {\n  const visitedNodes = [];\n  const unvisitedNodes = [];\n  //Set distance of start node\n  startNode.distance = 0;\n  startNode.visitedNode = true;\n  //Search from start node\n  unvisitedNodes.push(startNode);\n  //Loop until the whole grid is searched or \n  //trapped inside a wall\n  while (unvisitedNodes.length) {\n    let nextNode = unvisitedNodes.shift();\n    //Move around wall objects\n    if (!nextNode.wallNode) {\n      visitedNodes.push(nextNode);\n      //Reached target node\n      if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\n        return visitedNodes;\n      }\n      updateNeighbourNodes(unvisitedNodes, nextNode, grid, getNeighbourNodes);\n    }\n  }\n  return visitedNodes;\n}\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, getNeighbourNodes) {\n  const neighbourNodes = getNeighbourNodes(currNode, grid);\n  //Exclude visited nodes\n  const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\n  filteredNeighbourNodes.forEach(node => {\n    if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\n      node.distance = currNode.distance + Math.sqrt(2);\n    } else {\n      node.distance = currNode.distance + 1;\n    }\n    node.trackPrevNode = currNode;\n    node.visitedNode = true;\n    unvisitedNodes.push(node);\n  });\n}","map":{"version":3,"names":["breadthFirstSearch","grid","startNode","finishNode","getNeighbourNodes","visitedNodes","unvisitedNodes","distance","visitedNode","push","length","nextNode","shift","wallNode","row","column","updateNeighbourNodes","currNode","neighbourNodes","filteredNeighbourNodes","filter","node","forEach","Math","abs","sqrt","trackPrevNode"],"sources":["D:/Coding Projects/pathfinding/src/algorithms/breadthFirstSearch.js"],"sourcesContent":["export function breadthFirstSearch(grid, startNode, finishNode, getNeighbourNodes) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [];\r\n    //Set distance of start node\r\n    startNode.distance = 0;\r\n    startNode.visitedNode = true;\r\n    //Search from start node\r\n    unvisitedNodes.push(startNode);\r\n    //Loop until the whole grid is searched or \r\n    //trapped inside a wall\r\n    while (unvisitedNodes.length) {\r\n        let nextNode = unvisitedNodes.shift();\r\n        //Move around wall objects\r\n        if (!nextNode.wallNode) {\r\n            visitedNodes.push(nextNode);\r\n            //Reached target node\r\n            if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            updateNeighbourNodes(unvisitedNodes, nextNode, grid, getNeighbourNodes);\r\n        }\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, getNeighbourNodes) {\r\n    const neighbourNodes = getNeighbourNodes(currNode, grid);\r\n    //Exclude visited nodes\r\n    const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\r\n    filteredNeighbourNodes.forEach(node => {\r\n        if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\r\n            node.distance = currNode.distance + Math.sqrt(2);\r\n        } else {\r\n            node.distance = currNode.distance + 1;\r\n        }\r\n        \r\n        node.trackPrevNode = currNode;\r\n        node.visitedNode = true\r\n        unvisitedNodes.push(node);\r\n    }); \r\n}"],"mappings":"AAAA,OAAO,SAASA,kBAAkBA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAEC,iBAAiB,EAAE;EAC/E,MAAMC,YAAY,GAAG,EAAE;EACvB,MAAMC,cAAc,GAAG,EAAE;EACzB;EACAJ,SAAS,CAACK,QAAQ,GAAG,CAAC;EACtBL,SAAS,CAACM,WAAW,GAAG,IAAI;EAC5B;EACAF,cAAc,CAACG,IAAI,CAACP,SAAS,CAAC;EAC9B;EACA;EACA,OAAOI,cAAc,CAACI,MAAM,EAAE;IAC1B,IAAIC,QAAQ,GAAGL,cAAc,CAACM,KAAK,CAAC,CAAC;IACrC;IACA,IAAI,CAACD,QAAQ,CAACE,QAAQ,EAAE;MACpBR,YAAY,CAACI,IAAI,CAACE,QAAQ,CAAC;MAC3B;MACA,IAAIA,QAAQ,CAACG,GAAG,KAAKX,UAAU,CAACW,GAAG,IAAIH,QAAQ,CAACI,MAAM,KAAKZ,UAAU,CAACY,MAAM,EAAE;QAC1E,OAAOV,YAAY;MACvB;MAEAW,oBAAoB,CAACV,cAAc,EAAEK,QAAQ,EAAEV,IAAI,EAAEG,iBAAiB,CAAC;IAC3E;EACJ;EAEA,OAAOC,YAAY;AACvB;AAEA,SAASW,oBAAoBA,CAACV,cAAc,EAAEW,QAAQ,EAAEhB,IAAI,EAAEG,iBAAiB,EAAE;EAC7E,MAAMc,cAAc,GAAGd,iBAAiB,CAACa,QAAQ,EAAEhB,IAAI,CAAC;EACxD;EACA,MAAMkB,sBAAsB,GAAGD,cAAc,CAACE,MAAM,CAACC,IAAI,IAAI,CAACA,IAAI,CAACb,WAAW,CAAC;EAC/EW,sBAAsB,CAACG,OAAO,CAACD,IAAI,IAAI;IACnC,IAAIE,IAAI,CAACC,GAAG,CAACH,IAAI,CAACP,GAAG,GAAGG,QAAQ,CAACH,GAAG,CAAC,KAAK,CAAC,IAAIS,IAAI,CAACC,GAAG,CAACH,IAAI,CAACN,MAAM,GAAGE,QAAQ,CAACF,MAAM,CAAC,KAAK,CAAC,EAAE;MAC1FM,IAAI,CAACd,QAAQ,GAAGU,QAAQ,CAACV,QAAQ,GAAGgB,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC;IACpD,CAAC,MAAM;MACHJ,IAAI,CAACd,QAAQ,GAAGU,QAAQ,CAACV,QAAQ,GAAG,CAAC;IACzC;IAEAc,IAAI,CAACK,aAAa,GAAGT,QAAQ;IAC7BI,IAAI,CAACb,WAAW,GAAG,IAAI;IACvBF,cAAc,CAACG,IAAI,CAACY,IAAI,CAAC;EAC7B,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}