{"ast":null,"code":"/* Implementation of A * Search pathfinding algorithm using a priority queue */\nimport MinHeap from '../dataStructures/minHeap';\nexport function aStarSearch(grid, startNode, finishNode, weightValue, heuristicFunc, getNeighbourNodes) {\n  const visitedNodes = [];\n  const unvisitedNodes = new MinHeap();\n  //Set distance of start node\n  startNode.distance = 0;\n  startNode.visitedNode = true;\n\n  //Search from start node\n  unvisitedNodes.enqueue(startNode, startNode.distance);\n  //Loop until the whole grid is searched or \n  //trapped inside a wall\n  while (!unvisitedNodes.isEmpty()) {\n    let nextNode = unvisitedNodes.dequeue();\n\n    //Move around wall objects\n    if (!nextNode.wallNode) {\n      visitedNodes.push(nextNode);\n      //Reached target node\n      if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\n        return visitedNodes;\n      }\n      updateNeighbourNodes(unvisitedNodes, nextNode, startNode, finishNode, grid, weightValue, heuristicFunc, getNeighbourNodes);\n    }\n  }\n  return visitedNodes;\n}\nfunction updateNeighbourNodes(unvisitedNodes, currNode, startNode, finishNode, grid, weightValue, heuristicFunc, getNeighbourNodes) {\n  const neighbourNodes = getNeighbourNodes(currNode, grid);\n  let duplicatesSet = {};\n  //Exclude visited nodes\n  const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\n  filteredNeighbourNodes.forEach(node => {\n    if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\n      node.distance = currNode.distance + Math.sqrt(2);\n    } else {\n      node.distance = currNode.distance + 1;\n    }\n    node.trackPrevNode = currNode;\n    node.visitedNode = true;\n    //Count duplicate heuristic values for tiebreaker\n    let hValue = node.distance + heuristicFunc(node, finishNode);\n    if (duplicatesSet.hasOwnProperty(hValue)) duplicatesSet[hValue] = duplicatesSet[hValue] + 1;else {\n      duplicatesSet[hValue] = 1;\n    }\n  });\n  filteredNeighbourNodes.forEach(node => {\n    let hValue = node.distance + heuristicFunc(node, finishNode);\n    //Apply tiebreaker to duplicate nodes with same heuristic values\n    if (node.weightNode && duplicatesSet[hValue] > 1) {\n      unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + calcTiebreaker(currNode, startNode, finishNode) + weightValue);\n    } else if (node.weightNode) {\n      unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + weightValue);\n    } else if (duplicatesSet[hValue] > 1) {\n      unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + calcTiebreaker(currNode, startNode, finishNode));\n    } else {\n      unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode));\n    }\n  });\n}\nfunction calcTiebreaker(currNode, startNode, finishNode) {\n  //Calculate cross product\n  const dx1 = currNode.row - finishNode.row;\n  const dy1 = currNode.column - finishNode.column;\n  const dx2 = startNode.row - currNode.row;\n  const dy2 = startNode.column - currNode.column;\n  return Math.abs(dx1 * dy2 - dx2 * dy1) * 0.0001;\n}\nexport function calcManhattanDistance(currNode, finishNode) {\n  const deltaX = Math.abs(currNode.row - finishNode.row);\n  const deltaY = Math.abs(currNode.column - finishNode.column);\n  return 2 * (deltaX + deltaY);\n}\nexport function calcEuclideanDistance(currNode, finishNode) {\n  const deltaX = Math.abs(currNode.row - finishNode.row);\n  const deltaY = Math.abs(currNode.column - finishNode.column);\n  return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n}","map":{"version":3,"names":["MinHeap","aStarSearch","grid","startNode","finishNode","weightValue","heuristicFunc","getNeighbourNodes","visitedNodes","unvisitedNodes","distance","visitedNode","enqueue","isEmpty","nextNode","dequeue","wallNode","push","row","column","updateNeighbourNodes","currNode","neighbourNodes","duplicatesSet","filteredNeighbourNodes","filter","node","forEach","Math","abs","sqrt","trackPrevNode","hValue","hasOwnProperty","weightNode","calcTiebreaker","dx1","dy1","dx2","dy2","calcManhattanDistance","deltaX","deltaY","calcEuclideanDistance","pow"],"sources":["D:/Coding Projects/pathfinding/src/algorithms/aStarSearch.js"],"sourcesContent":["/* Implementation of A * Search pathfinding algorithm using a priority queue */\r\nimport MinHeap from '../dataStructures/minHeap';\r\n\r\nexport function aStarSearch(grid, startNode, finishNode, weightValue, heuristicFunc, getNeighbourNodes) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = new MinHeap();\r\n    //Set distance of start node\r\n    startNode.distance = 0;\r\n    startNode.visitedNode = true;\r\n    \r\n    //Search from start node\r\n    unvisitedNodes.enqueue(startNode, startNode.distance);\r\n    //Loop until the whole grid is searched or \r\n    //trapped inside a wall\r\n    while (!unvisitedNodes.isEmpty()) {\r\n        let nextNode = unvisitedNodes.dequeue();\r\n\r\n        //Move around wall objects\r\n        if (!nextNode.wallNode) {\r\n            visitedNodes.push(nextNode);\r\n            //Reached target node\r\n            if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            updateNeighbourNodes(unvisitedNodes, nextNode, startNode, finishNode, grid, weightValue, heuristicFunc, getNeighbourNodes);\r\n        }\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\n\r\nfunction updateNeighbourNodes(unvisitedNodes, currNode, startNode, finishNode, grid, weightValue, heuristicFunc, getNeighbourNodes) {\r\n    const neighbourNodes = getNeighbourNodes(currNode, grid);\r\n    let duplicatesSet = {};\r\n    //Exclude visited nodes\r\n    const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\r\n    filteredNeighbourNodes.forEach(node => {\r\n        if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\r\n            node.distance = currNode.distance + Math.sqrt(2);\r\n        } else {\r\n            node.distance = currNode.distance + 1;\r\n        }\r\n\r\n        node.trackPrevNode = currNode;\r\n        node.visitedNode = true\r\n        //Count duplicate heuristic values for tiebreaker\r\n        let hValue = node.distance + heuristicFunc(node, finishNode);\r\n        if (duplicatesSet.hasOwnProperty(hValue))\r\n            duplicatesSet[hValue] = duplicatesSet[hValue] + 1;\r\n        else {\r\n            duplicatesSet[hValue] = 1;\r\n        }\r\n    }); \r\n\r\n    filteredNeighbourNodes.forEach(node => {\r\n        let hValue = node.distance + heuristicFunc(node, finishNode);\r\n        //Apply tiebreaker to duplicate nodes with same heuristic values\r\n        if (node.weightNode && duplicatesSet[hValue] > 1) {\r\n            unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + calcTiebreaker(currNode, startNode, finishNode) + weightValue);\r\n        } else if (node.weightNode) {\r\n            unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + weightValue);\r\n        } else if (duplicatesSet[hValue] > 1) {\r\n            unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode) + calcTiebreaker(currNode, startNode, finishNode));\r\n        } else {\r\n            unvisitedNodes.enqueue(node, node.distance + heuristicFunc(node, finishNode));\r\n        }\r\n    }); \r\n}\r\n\r\nfunction calcTiebreaker(currNode, startNode, finishNode) {\r\n    //Calculate cross product\r\n    const dx1 = currNode.row - finishNode.row;\r\n    const dy1 = currNode.column - finishNode.column;\r\n    const dx2 = startNode.row - currNode.row;\r\n    const dy2 = startNode.column - currNode.column;\r\n    \r\n    return Math.abs(dx1 * dy2 - dx2 * dy1) * 0.0001;\r\n}\r\n\r\nexport function calcManhattanDistance(currNode, finishNode) {\r\n    const deltaX = Math.abs(currNode.row - finishNode.row);\r\n    const deltaY = Math.abs(currNode.column - finishNode.column);\r\n\r\n    return  2 * (deltaX + deltaY);\r\n}\r\n\r\nexport function calcEuclideanDistance(currNode, finishNode) {\r\n    const deltaX = Math.abs(currNode.row - finishNode.row);\r\n    const deltaY = Math.abs(currNode.column - finishNode.column);\r\n\r\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}