{"ast":null,"code":"export function depthFirstSearch(grid, startNode, finishNode, getNeighbourNodes) {\n  const visitedNodes = [];\n  const unvisitedNodes = [];\n  //Set distance of start node\n  startNode.distance = 0;\n  //Search from start node\n  unvisitedNodes.push(startNode);\n  //Loop until the whole grid is searched or \n  //trapped inside a wall\n  while (unvisitedNodes.length) {\n    let nextNode = unvisitedNodes.pop();\n    nextNode.visitedNode = true;\n    //Move around wall objects\n    if (!nextNode.wallNode) {\n      visitedNodes.push(nextNode);\n      //Reached target node\n      if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\n        return visitedNodes;\n      }\n      updateNeighbourNodes(unvisitedNodes, nextNode, grid, getNeighbourNodes);\n    }\n  }\n  return visitedNodes;\n}\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, getNeighbourNodes) {\n  const neighbourNodes = getNeighbourNodes(currNode, grid, getNeighbourNodes);\n  //Exclude visited nodes\n  const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\n  filteredNeighbourNodes.forEach(node => {\n    //Remove and re-add duplicate nodes to upper positions of the stack\n    if (unvisitedNodes.includes(node)) {\n      const index = unvisitedNodes.indexOf(node);\n      unvisitedNodes.splice(index, 1);\n    }\n    if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\n      node.distance = currNode.distance + Math.sqrt(2);\n    } else {\n      node.distance = currNode.distance + 1;\n    }\n    node.trackPrevNode = currNode;\n    unvisitedNodes.push(node);\n  });\n}","map":{"version":3,"names":["depthFirstSearch","grid","startNode","finishNode","getNeighbourNodes","visitedNodes","unvisitedNodes","distance","push","length","nextNode","pop","visitedNode","wallNode","row","column","updateNeighbourNodes","currNode","neighbourNodes","filteredNeighbourNodes","filter","node","forEach","includes","index","indexOf","splice","Math","abs","sqrt","trackPrevNode"],"sources":["D:/Coding Projects/pathfinding-algorithm-visualiser/src/algorithms/depthFirstSearch.js"],"sourcesContent":["export function depthFirstSearch(grid, startNode, finishNode, getNeighbourNodes) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [];\r\n    //Set distance of start node\r\n    startNode.distance = 0;\r\n    //Search from start node\r\n    unvisitedNodes.push(startNode);\r\n    //Loop until the whole grid is searched or \r\n    //trapped inside a wall\r\n    while (unvisitedNodes.length) {\r\n        let nextNode = unvisitedNodes.pop();\r\n        nextNode.visitedNode = true;\r\n        //Move around wall objects\r\n        if (!nextNode.wallNode) {\r\n            visitedNodes.push(nextNode);\r\n            //Reached target node\r\n            if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            updateNeighbourNodes(unvisitedNodes, nextNode, grid, getNeighbourNodes);\r\n        }\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, getNeighbourNodes) {\r\n    const neighbourNodes = getNeighbourNodes(currNode, grid, getNeighbourNodes);\r\n    //Exclude visited nodes\r\n    const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\r\n    filteredNeighbourNodes.forEach(node => {\r\n        //Remove and re-add duplicate nodes to upper positions of the stack\r\n        if (unvisitedNodes.includes(node)) {\r\n            const index = unvisitedNodes.indexOf(node);\r\n            unvisitedNodes.splice(index, 1);\r\n        }\r\n\r\n        if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\r\n            node.distance = currNode.distance + Math.sqrt(2);\r\n        } else {\r\n            node.distance = currNode.distance + 1;\r\n        }\r\n        \r\n        node.trackPrevNode = currNode;\r\n        unvisitedNodes.push(node);\r\n    });\r\n}"],"mappings":"AAAA,OAAO,SAASA,gBAAgBA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAEC,iBAAiB,EAAE;EAC7E,MAAMC,YAAY,GAAG,EAAE;EACvB,MAAMC,cAAc,GAAG,EAAE;EACzB;EACAJ,SAAS,CAACK,QAAQ,GAAG,CAAC;EACtB;EACAD,cAAc,CAACE,IAAI,CAACN,SAAS,CAAC;EAC9B;EACA;EACA,OAAOI,cAAc,CAACG,MAAM,EAAE;IAC1B,IAAIC,QAAQ,GAAGJ,cAAc,CAACK,GAAG,CAAC,CAAC;IACnCD,QAAQ,CAACE,WAAW,GAAG,IAAI;IAC3B;IACA,IAAI,CAACF,QAAQ,CAACG,QAAQ,EAAE;MACpBR,YAAY,CAACG,IAAI,CAACE,QAAQ,CAAC;MAC3B;MACA,IAAIA,QAAQ,CAACI,GAAG,KAAKX,UAAU,CAACW,GAAG,IAAIJ,QAAQ,CAACK,MAAM,KAAKZ,UAAU,CAACY,MAAM,EAAE;QAC1E,OAAOV,YAAY;MACvB;MAEAW,oBAAoB,CAACV,cAAc,EAAEI,QAAQ,EAAET,IAAI,EAAEG,iBAAiB,CAAC;IAC3E;EACJ;EAEA,OAAOC,YAAY;AACvB;AAEA,SAASW,oBAAoBA,CAACV,cAAc,EAAEW,QAAQ,EAAEhB,IAAI,EAAEG,iBAAiB,EAAE;EAC7E,MAAMc,cAAc,GAAGd,iBAAiB,CAACa,QAAQ,EAAEhB,IAAI,EAAEG,iBAAiB,CAAC;EAC3E;EACA,MAAMe,sBAAsB,GAAGD,cAAc,CAACE,MAAM,CAACC,IAAI,IAAI,CAACA,IAAI,CAACT,WAAW,CAAC;EAC/EO,sBAAsB,CAACG,OAAO,CAACD,IAAI,IAAI;IACnC;IACA,IAAIf,cAAc,CAACiB,QAAQ,CAACF,IAAI,CAAC,EAAE;MAC/B,MAAMG,KAAK,GAAGlB,cAAc,CAACmB,OAAO,CAACJ,IAAI,CAAC;MAC1Cf,cAAc,CAACoB,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IACnC;IAEA,IAAIG,IAAI,CAACC,GAAG,CAACP,IAAI,CAACP,GAAG,GAAGG,QAAQ,CAACH,GAAG,CAAC,KAAK,CAAC,IAAIa,IAAI,CAACC,GAAG,CAACP,IAAI,CAACN,MAAM,GAAGE,QAAQ,CAACF,MAAM,CAAC,KAAK,CAAC,EAAE;MAC1FM,IAAI,CAACd,QAAQ,GAAGU,QAAQ,CAACV,QAAQ,GAAGoB,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC;IACpD,CAAC,MAAM;MACHR,IAAI,CAACd,QAAQ,GAAGU,QAAQ,CAACV,QAAQ,GAAG,CAAC;IACzC;IAEAc,IAAI,CAACS,aAAa,GAAGb,QAAQ;IAC7BX,cAAc,CAACE,IAAI,CAACa,IAAI,CAAC;EAC7B,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}