{"ast":null,"code":"/* Priority Queue only implements necessary functions that will be used\r\n   Dijkstra's algorithm implementation uses a min heap */\n\nclass HeapEntry {\n  constructor(data, priority) {\n    this.data = data;\n    this.priority = priority;\n  }\n}\nexport default class MinHeap {\n  constructor() {\n    this.items = [];\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  enqueue(data, priority) {\n    const entry = new HeapEntry(data, priority);\n    let entryAdded = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].priority > entry.priority) {\n        this.items.splice(i, 0, entry);\n        entryAdded = true;\n        break;\n      }\n    }\n    //Add lowest priority entry or first entry in an empty array\n    !entryAdded && this.items.push(entry);\n  }\n  dequeue() {\n    if (!this.isEmpty()) {\n      //Remove first item\n      return this.items.shift().data;\n    }\n  }\n}","map":{"version":3,"names":["HeapEntry","constructor","data","priority","MinHeap","items","isEmpty","length","enqueue","entry","entryAdded","i","splice","push","dequeue","shift"],"sources":["D:/Coding Projects/pathfinding-algorithm-visualiser/src/dataStructures/minHeap.js"],"sourcesContent":["/* Priority Queue only implements necessary functions that will be used\r\n   Dijkstra's algorithm implementation uses a min heap */\r\n\r\nclass HeapEntry {\r\n    constructor(data, priority) {\r\n        this.data = data;\r\n        this.priority = priority;\r\n    }\r\n}\r\n\r\nexport default class MinHeap {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.items.length === 0;\r\n    }\r\n\r\n    enqueue(data, priority) {\r\n        const entry = new HeapEntry(data, priority);\r\n        let entryAdded = false;\r\n\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (this.items[i].priority > entry.priority) {\r\n                this.items.splice(i, 0, entry);\r\n                entryAdded = true;\r\n                break;\r\n            }\r\n        }\r\n        //Add lowest priority entry or first entry in an empty array\r\n        !entryAdded && this.items.push(entry);\r\n    }\r\n\r\n    dequeue() {\r\n        if (!this.isEmpty()) {\r\n            //Remove first item\r\n            return this.items.shift().data;\r\n        }\r\n    }\r\n}"],"mappings":"AAAA;AACA;;AAEA,MAAMA,SAAS,CAAC;EACZC,WAAWA,CAACC,IAAI,EAAEC,QAAQ,EAAE;IACxB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC5B;AACJ;AAEA,eAAe,MAAMC,OAAO,CAAC;EACzBH,WAAWA,CAAA,EAAG;IACV,IAAI,CAACI,KAAK,GAAG,EAAE;EACnB;EAEAC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACD,KAAK,CAACE,MAAM,KAAK,CAAC;EAClC;EAEAC,OAAOA,CAACN,IAAI,EAAEC,QAAQ,EAAE;IACpB,MAAMM,KAAK,GAAG,IAAIT,SAAS,CAACE,IAAI,EAAEC,QAAQ,CAAC;IAC3C,IAAIO,UAAU,GAAG,KAAK;IAEtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,KAAK,CAACE,MAAM,EAAEI,CAAC,EAAE,EAAE;MACxC,IAAI,IAAI,CAACN,KAAK,CAACM,CAAC,CAAC,CAACR,QAAQ,GAAGM,KAAK,CAACN,QAAQ,EAAE;QACzC,IAAI,CAACE,KAAK,CAACO,MAAM,CAACD,CAAC,EAAE,CAAC,EAAEF,KAAK,CAAC;QAC9BC,UAAU,GAAG,IAAI;QACjB;MACJ;IACJ;IACA;IACA,CAACA,UAAU,IAAI,IAAI,CAACL,KAAK,CAACQ,IAAI,CAACJ,KAAK,CAAC;EACzC;EAEAK,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC,IAAI,CAACR,OAAO,CAAC,CAAC,EAAE;MACjB;MACA,OAAO,IAAI,CAACD,KAAK,CAACU,KAAK,CAAC,CAAC,CAACb,IAAI;IAClC;EACJ;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}