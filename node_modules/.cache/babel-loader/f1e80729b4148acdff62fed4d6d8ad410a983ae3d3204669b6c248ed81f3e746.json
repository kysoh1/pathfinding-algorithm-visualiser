{"ast":null,"code":"/* Implementation of Dijkstra's pathfinding algorithm using a priority queue */\nimport MinHeap from '../dataStructures/minHeap';\nexport function dijkstra(grid, startNode, finishNode, weightValue, getNeighbourNodes) {\n  const visitedNodes = [];\n  const unvisitedNodes = new MinHeap();\n  //Set distance of start node\n  startNode.distance = 0;\n  startNode.visitedNode = true;\n\n  //Search from start node\n  unvisitedNodes.enqueue(startNode, startNode.distance);\n  //Loop until the whole grid is searched or \n  //trapped inside a wall\n  while (!unvisitedNodes.isEmpty()) {\n    let nextNode = unvisitedNodes.dequeue();\n\n    //Move around wall objects\n    if (!nextNode.wallNode) {\n      visitedNodes.push(nextNode);\n      //Reached target node\n      if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\n        return visitedNodes;\n      }\n      updateNeighbourNodes(unvisitedNodes, nextNode, grid, weightValue, getNeighbourNodes);\n    }\n  }\n  return visitedNodes;\n}\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, weightValue, getNeighbourNodes) {\n  const neighbourNodes = getNeighbourNodes(currNode, grid, getNeighbourNodes);\n  //Exclude visited nodes\n  const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\n  filteredNeighbourNodes.forEach(node => {\n    if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\n      node.distance = currNode.distance + Math.sqrt(2);\n    } else {\n      node.distance = currNode.distance + 1;\n    }\n    node.trackPrevNode = currNode;\n    node.visitedNode = true;\n    if (node.weightNode) {\n      unvisitedNodes.enqueue(node, node.distance + weightValue);\n    } else {\n      unvisitedNodes.enqueue(node, node.distance);\n    }\n  });\n}","map":{"version":3,"names":["MinHeap","dijkstra","grid","startNode","finishNode","weightValue","getNeighbourNodes","visitedNodes","unvisitedNodes","distance","visitedNode","enqueue","isEmpty","nextNode","dequeue","wallNode","push","row","column","updateNeighbourNodes","currNode","neighbourNodes","filteredNeighbourNodes","filter","node","forEach","Math","abs","sqrt","trackPrevNode","weightNode"],"sources":["D:/Coding Projects/pathfinding-algorithm-visualiser/src/algorithms/dijkstra.js"],"sourcesContent":["/* Implementation of Dijkstra's pathfinding algorithm using a priority queue */\r\nimport MinHeap from '../dataStructures/minHeap';\r\n\r\nexport function dijkstra(grid, startNode, finishNode, weightValue, getNeighbourNodes) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = new MinHeap();\r\n    //Set distance of start node\r\n    startNode.distance = 0;\r\n    startNode.visitedNode = true;\r\n    \r\n    //Search from start node\r\n    unvisitedNodes.enqueue(startNode, startNode.distance);\r\n    //Loop until the whole grid is searched or \r\n    //trapped inside a wall\r\n    while (!unvisitedNodes.isEmpty()) {\r\n        let nextNode = unvisitedNodes.dequeue();\r\n\r\n        //Move around wall objects\r\n        if (!nextNode.wallNode) {\r\n            visitedNodes.push(nextNode);\r\n            //Reached target node\r\n            if (nextNode.row === finishNode.row && nextNode.column === finishNode.column) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            updateNeighbourNodes(unvisitedNodes, nextNode, grid, weightValue, getNeighbourNodes);\r\n        }\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\nfunction updateNeighbourNodes(unvisitedNodes, currNode, grid, weightValue, getNeighbourNodes) {\r\n    const neighbourNodes = getNeighbourNodes(currNode, grid, getNeighbourNodes);\r\n    //Exclude visited nodes\r\n    const filteredNeighbourNodes = neighbourNodes.filter(node => !node.visitedNode);\r\n    \r\n    filteredNeighbourNodes.forEach(node => {\r\n        if (Math.abs(node.row - currNode.row) === 1 && Math.abs(node.column - currNode.column) === 1) {\r\n            node.distance = currNode.distance + Math.sqrt(2);\r\n        } else {\r\n            node.distance = currNode.distance + 1;\r\n        }\r\n        \r\n        node.trackPrevNode = currNode;\r\n        node.visitedNode = true;\r\n\r\n        if (node.weightNode) {\r\n            unvisitedNodes.enqueue(node, node.distance + weightValue);\r\n        } else {\r\n            unvisitedNodes.enqueue(node, node.distance);\r\n        }\r\n    });\r\n}"],"mappings":"AAAA;AACA,OAAOA,OAAO,MAAM,2BAA2B;AAE/C,OAAO,SAASC,QAAQA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAEC,WAAW,EAAEC,iBAAiB,EAAE;EAClF,MAAMC,YAAY,GAAG,EAAE;EACvB,MAAMC,cAAc,GAAG,IAAIR,OAAO,CAAC,CAAC;EACpC;EACAG,SAAS,CAACM,QAAQ,GAAG,CAAC;EACtBN,SAAS,CAACO,WAAW,GAAG,IAAI;;EAE5B;EACAF,cAAc,CAACG,OAAO,CAACR,SAAS,EAAEA,SAAS,CAACM,QAAQ,CAAC;EACrD;EACA;EACA,OAAO,CAACD,cAAc,CAACI,OAAO,CAAC,CAAC,EAAE;IAC9B,IAAIC,QAAQ,GAAGL,cAAc,CAACM,OAAO,CAAC,CAAC;;IAEvC;IACA,IAAI,CAACD,QAAQ,CAACE,QAAQ,EAAE;MACpBR,YAAY,CAACS,IAAI,CAACH,QAAQ,CAAC;MAC3B;MACA,IAAIA,QAAQ,CAACI,GAAG,KAAKb,UAAU,CAACa,GAAG,IAAIJ,QAAQ,CAACK,MAAM,KAAKd,UAAU,CAACc,MAAM,EAAE;QAC1E,OAAOX,YAAY;MACvB;MAEAY,oBAAoB,CAACX,cAAc,EAAEK,QAAQ,EAAEX,IAAI,EAAEG,WAAW,EAAEC,iBAAiB,CAAC;IACxF;EACJ;EAEA,OAAOC,YAAY;AACvB;AAEA,SAASY,oBAAoBA,CAACX,cAAc,EAAEY,QAAQ,EAAElB,IAAI,EAAEG,WAAW,EAAEC,iBAAiB,EAAE;EAC1F,MAAMe,cAAc,GAAGf,iBAAiB,CAACc,QAAQ,EAAElB,IAAI,EAAEI,iBAAiB,CAAC;EAC3E;EACA,MAAMgB,sBAAsB,GAAGD,cAAc,CAACE,MAAM,CAACC,IAAI,IAAI,CAACA,IAAI,CAACd,WAAW,CAAC;EAE/EY,sBAAsB,CAACG,OAAO,CAACD,IAAI,IAAI;IACnC,IAAIE,IAAI,CAACC,GAAG,CAACH,IAAI,CAACP,GAAG,GAAGG,QAAQ,CAACH,GAAG,CAAC,KAAK,CAAC,IAAIS,IAAI,CAACC,GAAG,CAACH,IAAI,CAACN,MAAM,GAAGE,QAAQ,CAACF,MAAM,CAAC,KAAK,CAAC,EAAE;MAC1FM,IAAI,CAACf,QAAQ,GAAGW,QAAQ,CAACX,QAAQ,GAAGiB,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC;IACpD,CAAC,MAAM;MACHJ,IAAI,CAACf,QAAQ,GAAGW,QAAQ,CAACX,QAAQ,GAAG,CAAC;IACzC;IAEAe,IAAI,CAACK,aAAa,GAAGT,QAAQ;IAC7BI,IAAI,CAACd,WAAW,GAAG,IAAI;IAEvB,IAAIc,IAAI,CAACM,UAAU,EAAE;MACjBtB,cAAc,CAACG,OAAO,CAACa,IAAI,EAAEA,IAAI,CAACf,QAAQ,GAAGJ,WAAW,CAAC;IAC7D,CAAC,MAAM;MACHG,cAAc,CAACG,OAAO,CAACa,IAAI,EAAEA,IAAI,CAACf,QAAQ,CAAC;IAC/C;EACJ,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}